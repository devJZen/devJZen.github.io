---
layout: post
title: Chapter 2-3. 데이터 (Data)
categories: web3
tags: [Blockchain]
---
> 노드 간의 합의로 변경된 최종 결과, 모든 거래 기록(블록)을 물리적으로 저장하고 관리한다.

탈중앙화로 인하여 여러 컴퓨터 네트워크에 데이터를 분산시킨다는 점에서 기존의 중앙화된 데이터베이스와 다르다. 이러한 분산 특성과 암호화 기술은 블록체인의 데이터베이스를 변경 불가능하게 하고 투명하게 유지하도록 한다. 데이터는 블록으로 그룹화된다. 이 때, 새로운 거래나 데이터는 블록으로 그룹화한다.

- 논리적 데이터 : 상태 (State), 트랜잭션, 블록
- 관리 인터페이스: StateDB
- 물리적 저장소: [LevelDB](https://github.com/google/leveldb), [PebbleDB](https://github.com/cockroachdb/pebble), [RocksDB](https://github.com/facebook/rocksdb)

LevelDB, PebbleDB, RocksDB는 모두 LSM(Log-Structured Merge-Tree) 트리 데이터 구조를 기반으로 하는 고성능 임베디드 키-값 저장소다.

> [!info] LSM 트리는 왜 사용할까?  
> 대다수의 데이터베이스는 B-트리라는 구조를 사용한다. 그러나 새로운 내용을 추가하려면, 정확한 페이지를 찾아야 되며 페이지가 꽉 찼다면 다른 내용을 뒤로 밀어내는 등의 복잡한 작업이 필요하다. 이런 작업은 '랜덤 쓰기'라고 불리기도하며 매우 느리다. 이걸 개선하기 위한 방식이 LSM 트리 구조이다. 저장할 내용이 있으면 빠른 메모장(MemTable)에 순서 없이 적고, 메모장이 꽉 차면, 내용을 가지런히 정리해서 새 공책(SSTable)을 만들어서 차곡차곡 쌓아두자는('순차 쓰기') 구조다. 속도가 빠른 대신 오래된 정보는 여러 공책에 흩어져 있을 수 있어서 확인할 사항들이 많다. 그래서 컴팩션(Compaction)이라는 정리 작업이 배경에서 주기적으로 실행된다. 나눠진 공책의 내용들을 합쳐서 중복된 내용을 지우고 더 깔끔한 페이지로 만들어서 수고를 덜어준다.

<div class="mermaid">
graph TD
    subgraph "메모리 (Memory)"
        A["쓰기 (Write)"] --> B{"멤테이블 (MemTable)"};
        A --> C["쓰기 전 로그 (WAL)"];
    end
    
    subgraph "디스크 (Disk)"
        D["불변 멤테이블 (Immutable MemTable)"] -- 플러시 (Flush) --> E["SSTable<br/>레벨 0 (Level 0)"];
        E -- 컴팩션 (Compaction) --> F["SSTable<br/>레벨 1 (Level 1)"];
        F -- 컴팩션 (Compaction) --> G["SSTable<br/>레벨 2 (Level 2)"];
        G -- "..." --> H["SSTable<br/>레벨 N (Level N)"];
    end

    B -- 가득 참 (Full) --> D;

    style B fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#ccf,stroke:#333,stroke-width:2px
    style F fill:#ccf,stroke:#333,stroke-width:2px
    style G fill:#ccf,stroke:#333,stroke-width:2px
    style H fill:#ccf,stroke:#333,stroke-width:2px
</div>

**LevelDB**

구글에서 개발했다. Bigtable의 개념에서 영감을 받아 만들어졌고 C++로 작성되었다. 다른 LSM 기반 저장소의 기반이 되는 라이브러리 역할을 한다.

**PebbleDB**

Cockroach Labs에서 개발했다. Go로 작성되었고 RocksDB에서 큰 영감을 받았다. CockroachDB의 요구에 초점을 맞춰서 개발되었다.

**RocksDB**

페이스북이 LevelDB의 한계를 극복하고자 만들었다. 멀티코어 서버와 SSD, NVMe 와 같은 스토리지에서 최고의 성능을 내기 위해 만들어졌다. LevelDB의 fork로 C++로 작성되었다.

- Column Families: 단일 데이터베이스를 여러 논리적 저장소로 분할하여 다른 구성을 가질 수 있게 한다.
- 트랜잭션
- 고급 연산
- 튜닝 가능성

MariaDB, ArangoDB, TiKV 등 여러 고성능 데이터베이스 및 시스템의 사실상 표준 스토리지 엔진이 되었다.

**MonadDB**

MonadDB는 고성능 L1 블록체인인 Monad를 위해 특별히 개발된 데이터베이스다. Monad는 EVM과 완벽하게 호환되면서도 병렬 실행(Parallel Execution)을 통해 초당 10,000건 이상의 트랜잭션을 처리하는 것을 목표로 하며, MonadDB는 이러한 아키텍처를 뒷받침하는 핵심 요소다.

==RocksDB를 기반으로 하지만, 블록체인 상태 저장(EVM의 머클 패트리샤 트리)에 대한 병목 현상을 해결하기 위해 비동기 I/O(Asynchronous I/O)와 직접 스토리지 접근(Direct I/O)과 같은 기능을 구현하여 대대적으로 최적화되었다. 이를 통해 디스크에서 데이터를 읽어오는 동안 다른 트랜잭션을 동시에 처리할 수 있어 병렬 실행의 효율을 극대화한다.==

- **주요 특징**:
  - EVM 상태 저장을 위한 최초의 전용 데이터베이스
  - 병렬 실행을 지원하는 비동기 I/O
  - SSD 성능을 최대한 활용하기 위한 파일 시스템 우회
  - RAM 대신 SSD에 대부분의 상태를 효율적으로 저장하여 노드 운영 비용 절감[^1]

[^1]: [Monad-db: A custom database for the EVM](https://monad.xyz/blog/monad-db)
