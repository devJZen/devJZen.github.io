---
layout: post
title: 왜 POST와 GET 요청만 사용할까?
categories: study
tags: [RESTful API]
---

## 도대체 왜 POST와 GET 요청만 할까?

> ajax 요청을 하는데 왜 GET과 POST만 쓰지?

개발 공부를 하다보면 프로젝트에 의문이 생기는 경우가 많다. 특히, 이런 의문을 풀기 위해 질문을 하다보면 가끔은 납득할 수 없는 대답이 돌아오기도 한다. 시니어 개발자가 신입이라고 단정짓고 쉬운 방식을 알려준 것인가 아니면 일부러 잘못된 지식을 알려주는 것일까, 그것도 아니라면 개발자로서 처음 공부했던 내용만 알고 요즘의 개발 지식과 트렌드를 몰라서 이런 방법을 알려주는 것일까? 알고있던 지식과의 괴리가 생기며 고민이 생긴다. 내 궁금증을 해결하고자 상대방을 귀찮게 하기엔 다들 일이 너무 많다. 그럼 퇴근하고 공부하면 된다.

하드코딩은 DB 설계를 담당하는 사람에 따라 달라지거나 프로젝트 특성상 프로토타입이 개발에 들어간 후에 정리되는 경우도 있다. 그래서 고작 이제 2년차가 되어가는 나의 경험으로 함부로 단정짓기 어렵다. 예를 들어 문자열을 "이렇게 쓸 것이냐" 아니면 전역변수로 객체화 하여서 String this = "이렇게 쓸 것이냐"로 정의 내리고 쓸 때마다 this를 사용하는 차이가 있다. 납기일이 촉박하다면 "우선은 이렇게 사용하고 유지보수할 때 공통화 하자" 할수도 있는 것이고, 시간이 넉넉하다면 자주 사용하는 변수일 경우에 공통으로 관리해서 this를 사용하자고 개발 표준을 잡기도 한다. 리더의 성향에 따라 달라지는 문제여서 판단을 내리기 어렵다.
그리고 이건 API 설계에도 마찬가지로 적용된다. 이유가 있어서 GET과 POST 요청 두가지를 사용했을텐데 도대체 왜 그랬을까?

## 선배님! 왜 우리 프로젝트는 GET과 POST 요청 두가지만 사용하는 건가요?

> 내 후배가 이렇게 질문한다면 난 뭐라고 대답해야할까?

왜 GET과 POST만 사용할까? 나름의 가설을 세워보았다.

1. html 웹 폼은 GET과 POST를 지원하므로 (개발자가 편해서 생산성에 도움이 된다고 생각하여)
2. 사용자 입력을 통해 PUT과 DELETE 요청이 발생할 경우에 대응하는 프로세스가 없어서
3. ajax 통신으로 인한 http 요청 시에 개발 표준에 대한 지식이 없어서
4. 예전부터 그렇게 사용했으므로 (익숙함의 문제로)
5. 데이터 삭제 요청시 물리삭제 보다는 flag 변경을 주로한다는 이유로(데이터 수정에 가까워서, 그렇다면 PUT 요청은 왜 사용하지 않았던 것인가?)
6. 신입 개발자가 다수 포함된 프로젝트여서 신입들의 수준에서 이런 고민을 할 필요가 없다고 생각했으므로 (리더의 가치판단 개입)

이러다간 고민을 하다가 끝이 나지 않을 것 같아서 GET과 POST 요청만 사용했을 시에 얻는 이득과 RESTful API 표준을 정확히 지켜서 진행한 프로젝트는 어떤 차이가 있을지 생각해보자.

## GET 과 POST 요청만 사용한 프로젝트

> 장점: 초기 설계 복잡도가 낮다.

> 단점: 가독성이 떨어지고 API 일관성이 낮다.

CRUD 연산을 PUT, DELETE에 매핑하는 RESSTful API 디자인이 보편화된 최근 트렌드에 부응하지 못 한다.

다른 메서드 요청을 사용하지 않고 POST 만을 사용할 경우에 오버헤드가 증가할 가능성이 많다.

기능을 추가할 경우에 엔드포인트가 늘어난다.


## RESTful API 설계 표준을 정확히 준수하는 프로젝트

> 장점: 초기 설계 복잡도가 높다.

> 단점: 딱히 없다.

## 장단점 비교

| 구분 | RESTful API 설계 프로젝트 | GET/POST 요청만 사용한 프로젝트 |
| 설계 원칙 | 자원(Resource) 중심: 모든 것을 자원으로 간주하고 URI로 표현
Stateless: 서버는 클라이언트의 상태를 저장하지 않음
균일한 인터페이스: HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용해 자원 조작
HATEOAS: 애플리케이션 상태 전이의 엔진으로서 하이퍼미디어 | 기능/액션 중심: 특정 기능을 수행하는 엔드포인트에 초점
상대적으로 덜 엄격한 Stateless: 경우에 따라 서버가 클라이언트 상태를 유지하는 방식도 사용될 수 있음
제한된 HTTP 메서드: GET과 POST만 주로 사용하며, 때로는 URL 쿼리 파라미터나 요청 바디를 통해 '액션'을 명시 |
| 명확성 및 가독성 | 높음: URI와 HTTP 메서드 조합만으로 어떤 자원에 어떤 작업을 하는지 직관적으로 파악 가능
  예: GET /users/123 (123번 사용자 조회), DELETE /products/456 (456번 제품 삭제) | 낮음/혼란스러울 수 있음: 모든 작업을 GET/POST로 처리하므로 URI나 바디 내용을 확인해야 정확한 작업 파악 가능
  예: POST /api/userAction?action=delete&id=123 또는 POST /deleteUser |
| API 일관성 | 높음: HTTP 표준에 따라 일관된 방식으로 자원을 다루므로, 다양한 개발자들이 쉽게 이해하고 사용 가능
API 문서화 및 유지보수가 용이 | 낮음: 각 기능마다 엔드포인트명이나 파라미터 구조가 다를 수 있어 일관성이 부족할 수 있음
API 문서화 및 유지보수에 더 많은 노력 필요 |
| 캐싱 | 효율적: GET 요청에 대한 응답은 캐싱이 가능하여 네트워크 트래픽 및 서버 부하 감소에 유리
HTTP 캐싱 메커니즘을 적극 활용 가능 | 제한적: GET 요청만 캐싱 가능하고, POST 요청은 기본적으로 캐싱되지 않음
GET 요청도 URL에 따라 캐싱 효율이 떨어질 수 있음 |
| 확장성 및 유지보수 | 용이: 새로운 자원이나 기능 추가 시 기존 구조에 영향을 덜 주면서 확장 가능
모듈화 및 재사용성이 높음
API 버전 관리에 유리 | 어려움: 기능 추가 시 기존 엔드포인트의 변경이 필요하거나, 새로운 엔드포인트가 계속 추가되어 복잡해질 수 있음
특정 기능에 종속적인 구조가 될 수 있음 |
| 보안 | 	
GET 요청은 URL에 노출되므로 민감 정보 전송에 부적합. POST, PUT, DELETE는 HTTP Body를 사용하므로 URL 노출 위험 적음
HTTPS 적용은 필수 | - GET 요청은 URL에 노출되므로 민감 정보 전송에 부적합. POST는 HTTP Body를 사용하므로 URL 노출 위험 적음
HTTPS 적용은 필수 |
| 개발 복잡도 | 초기 설계 복잡도 높음: REST 원칙에 대한 이해와 자원 설계에 대한 고민 필요
 장기적 복잡도 낮음: 일단 설계되면 개발 및 관리가 용이 | 초기 설계 복잡도 낮음: 간단하게 필요한 기능별로 엔드포인트 생성 가능
 장기적 복잡도 높음: API가 많아지고 복잡해질수록 관리 및 이해가 어려워짐 |
| 브라우저/프레임워크 호환성 | 최신 브라우저 및 대부분의 프레임워크에서 완벽 지원: Ajax(fetch, Axios 등) 라이브러리를 통해 PUT, DELETE 요청 용이 | 거의 모든 환경에서 완벽 지원: 가장 기본적인 HTTP 메서드이므로 호환성 문제 거의 없음
레거시 환경에서도 무리 없이 사용 가능 |
| 성능 | 효율적: 캐싱, HTTP 상태 코드 활용 등으로 전반적인 성능 개선에 유리
PUT/DELETE 자체의 오버헤드는 미미 | 상대적으로 비효율적일 수 있음: 캐싱 활용이 제한적이며, 모든 요청을 POST로 처리할 경우 오버헤드 증가 가능성 |
| 주요 사용 사례 | 최신 웹/모바일 애플리케이션 백엔드: 클라이언트-서버 간 데이터 통신
마이크로서비스 아키텍처: 서비스 간 통신
오픈 API: 외부 개발자에게 API 제공 | 레거시 시스템 마이그레이션: 기존 시스템의 비즈니스 로직을 유지하면서 웹 인터페이스 추가
단순한 웹폼 제출: 특정 페이지에서의 특정 액션 수행
RESTful 개념이 도입되기 전/덜 중요시되던 시기의 프로젝트 |

## 결론

> 가능하다면 RESTful API 설계를 하도록 하자

## RESTful API 설계를 위한 http 메서드

> GET

특정 리소스의 표현을 요청합니다. GET 요청은 데이터를 검색하는 데 사용되며, 서버의 상태를 변경하지 않아야 합니다(즉, 안전합니다). 또한, 여러 번 반복해서 요청해도 동일한 결과를 반환하므로 멱등성을 가집니다.

- 데이터 조회에 사용됩니다.

- 요청 본문(body)이 없습니다.

- 쿼리 파라미터(URL에 ?key=value&... 형태로 추가)를 통해 데이터를 전달합니다.

- 브라우저에서 직접 URL을 입력하거나 링크를 클릭할 때 사용되는 기본 메서드입니다.

- 캐싱이 가능합니다.

> POST

서버에 데이터를 제출하여 새로운 리소스를 생성하거나, 기존 리소스에 데이터를 추가하거나, 특정 작업을 수행하도록 요청합니다. POST 요청은 서버의 상태를 변경할 수 있으며, 여러 번 반복해서 요청할 경우 매번 다른 결과(예: 새로운 리소스 생성)를 가져올 수 있으므로 안전하지 않고 멱등성도 없습니다.

- 주로 새로운 리소스 생성에 사용됩니다.

- 데이터를 요청 본문(body)에 담아 전송합니다.

- 파일 업로드, 웹 폼 데이터 제출 등에 사용됩니다.

- 캐싱되지 않습니다.

> PUT

요청 본문에 포함된 데이터로 대상 리소스 전체를 대체하거나, 해당 리소스가 존재하지 않으면 새로 생성합니다. PUT 요청은 동일한 요청을 여러 번 보내도 결과가 동일하므로 멱등성을 가집니다.

- 리소스의 완전한 갱신 또는 생성을 목적으로 합니다.

- 클라이언트는 리소스의 URI를 명확하게 지정해야 합니다.

- 부분적인 업데이트가 아닌 리소스 전체를 대체합니다.

> DELETE

특정 리소스를 삭제하도록 요청합니다. DELETE 요청은 여러 번 반복해도 동일하게 리소스가 삭제된 상태를 유지하므로 멱등성을 가집니다.

- 리소스 제거에 사용됩니다.

- 요청 본문(body)은 일반적으로 사용되지 않습니다.

- 성공적인 삭제는 200 (OK), 202 (Accepted), 204 (No Content) 등의 상태 코드로 응답합니다.

> HEAD

GET 요청과 동일한 응답 헤더를 요청하지만, 응답 본문(body)은 포함하지 않습니다.

- 리소스의 메타데이터(크기, 마지막 수정일, 콘텐츠 타입 등)만 확인하고자 할 때 사용됩니다.

- 실제로 리소스를 다운로드하지 않고도 리소스의 존재 여부나 변경 여부를 확인할 수 있어 대역폭 절약에 유용합니다.

- 안전하고 멱등성을 가집니다.

> OPTIONS

대상 리소스에 대해 클라이언트가 수행할 수 있는 HTTP 메서드(허용되는 메서드)나 다른 통신 옵션에 대한 정보를 요청합니다.

- 주로 웹 애플리케이션에서 CORS(Cross-Origin Resource Sharing) 요청을 보내기 전, 실제 요청을 보낼지 여부를 결정하기 위한 "사전 요청(Preflight Request)"으로 사용됩니다.

- 서버는 Allow 헤더에 해당 리소스에 대해 허용되는 메서드 목록을 포함하여 응답합니다.

- 안전하고 멱등성을 가집니다.


> PATCH

대상 리소스의 일부를 수정하는 데 사용됩니다. PUT이 리소스 전체를 대체하는 반면, PATCH는 리소스의 특정 필드만 수정할 수 있습니다. PATCH는 일반적으로 멱등성을 가지지 않습니다.

- 멱등성을 가지지 않으므로, 동일한 PATCH 요청을 여러 번 보내면 의도치 않은 결과가 발생할 수 있습니다.

- 리소스의 부분적인 업데이트에 사용됩니다.

> CONNECT

대상 리소스로의 터널 연결을 설정합니다. 주로 프록시 서버를 통해 SSL/TLS 암호화된 통신(HTTPS)을 설정할 때 사용됩니다.

[HTTP1](https://www.rfc-editor.org/rfc/rfc9110.html) [HTTP2](https://http2.github.io/) [HTTP3](https://httpwg.org/specs/rfc9114.html)

## 내가 궁금했던 내용

> 멱등성이란?

여러 개의 동일한 요청이 동일한 효과를 반환한다. safe 타입의 메서드는 멱등성을 가지고 있다. 비멱등 메서드는 POST, PATCH, CONNECT가 있다. [참조](https://developer.mozilla.org/en-US/docs/Glossary/Idempotent)

> GET과 PUT의 차이

GET은 여러번의 요청이 있어도 서버의 상태가 변하지 않는다. PUT은 데이터가 없으면 생성할 수 있고 이미 있다면, 수정할 수 있다. 여러번의 요청이 있다면 우리가 요청한 데이터로 서버는 같은 상태를 유지한다. [참조](https://velog.io/@dion/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0)

> GET과 POST가 아닌 다른 메서드는 오버헤드를 발생시킨다?

HTTP 통신의 오버헤드는 메서드 요청에 의해 발생되는 것이 아니다. 네트워크 왕복 시간, 데이터의 크기, 헤더 정보, 연결 설정/해제 등의 문제로 발생되기 때문에 메서드의 사용만으로 판단하기엔 어렵다.

> 보안의 관점에서 RESTful API란?

원칙에 따라 올바르게 사용한다면 멱등성 활용 측면에서 네트워크 오류로 인한 요청이 재시도될 때 안전하게 처리될 수 있다.
