---
layout: post
title: Go로 작성한 합의 연구
categories: web3
tags: [web3]
---

Go를 기반으로 PoW, PoS, PoH에 대하여 알고리즘이 어떻게 구현되는지 만들어봤습니다.  
[**Github 프로젝트**](https://github.com/devJZen/consensus-study-go)

---

### 1. 작업증명 (Proof of Work)

#### 구현 방식
`pow/` 디렉터리의 코드는 비트코인의 작업증명 방식을 간결하게 구현했습니다. `Block` 구조체에 `Nonce` 값을 포함하고, `ProofOfWork` 구조체는 채굴 난이도를 나타내는 `target` 값을 가집니다. `Run` 함수는 `Nonce`를 1씩 증가시키며 `target`보다 낮은 해시값을 찾는 무한 루프를 실행하여 채굴 과정을 시뮬레이션합니다. 해시 파워를 이용한 경쟁적인 문제 풀이를 통해 블록 생성 권한을 얻는 PoW의 핵심 원리를 표현하고자 했습니다.

#### 개선 제안
- **동적 난이도 조절**: 현재는 난이도(`target`)가 고정되어 있습니다. 실제 블록체인처럼 네트워크의 전체 해시 파워에 따라 주기적으로 채굴 난이도를 재조정하는 로직을 추가하면 더 현실적인 시뮬레이션이 될 수 있습니다.
- **네트워크 구현**: 현재는 단일 노드에서의 시뮬레이션입니다. 간단한 P2P 네트워크를 구현하여 여러 노드가 블록을 전파하고 가장 긴 체인을 선택하는 'Longest Chain Rule'을 구현하면 PoW의 동적인 특성을 더 잘 이해할 수 있습니다.
- **트랜잭션 풀(Mempool)**: 블록에 데이터를 직접 넣는 대신, 실제 블록체인처럼 트랜잭션을 담아두는 '멤풀'을 구현하고, 채굴 시 멤풀에서 트랜잭션을 선택하여 블록에 포함시키는 구조로 개선할 수 있습니다.

> [!info] 멤풀(Mempool)과 PoW 시스템의 관계  
> 제안된 '트랜잭션 풀(멤풀)'은 PoW의 핵심 알고리즘(해시 계산)에 포함되지는 않지만, PoW를 사용하는 블록체인 **시스템**이 작동하기 위한 필수적인 구성 요소입니다.  
> 1.  **멤풀의 역할**: '미확인 거래'들이 블록에 포함되기 전에 대기하는 공간입니다.  
> 2.  **채굴자의 역할**: 채굴자는 PoW 작업을 시작하기 전, 먼저 멤풀에서 수수료가 높거나 오래된 거래들을 골라 '블록 후보'를 만듭니다.  
> 3.  **PoW의 역할**: 채굴자는 이렇게 만들어진 '블록 후보'를 대상으로 정답 `Nonce`를 찾는 해시 퍼즐을 풉니다.  
> 따라서 멤풀을 추가하자는 제안은, 현재 코드에서 `data` 필드를 단순 문자열로 채우는 방식을 '멤풀에서 트랜잭션을 선택하여 채우는' 현실적인 방식으로 확장하자는 의미입니다.

### 2. 지분증명 (Proof of Stake)

#### 구현 방식
`pos/` 디렉터리에서는 지분량에 따라 블록 생성자를 선정하는 복권(Lottery) 기반의 PoS를 구현했습니다. `Blockchain` 구조체에 각 검증자(Validator)와 그들의 지분(Stake)을 맵으로 저장합니다. `pickWinner` 함수는 각 검증자의 지분만큼 '복권'을 `lotteryPool`에 넣고, 그중 하나를 무작위로 추첨하여 다음 블록 생성자를 결정합니다. 지분이 많을수록 당첨 확률이 높아지는 PoS의 기본 개념을 효과적으로 보여줍니다.

#### 개선 제안
- **검증 가능한 무작위 함수 (VRF)**: 현재 무작위 선정 방식은 외부에서 예측하거나 조작할 여지가 있을 수 있습니다. VRF(Verifiable Random Function)를 도입하면, 검증자가 무작위 값을 생성하되 그 값이 정당하게 생성되었음을 다른 노드들이 검증할 수 있어 보안성을 크게 높일 수 있습니다.
- **슬래싱 (Slashing) 조건 추가**: 악의적인 행동(예: 이중 서명)을 한 검증자의 지분을 삭감하는 '슬래싱' 규칙을 추가하면 네트워크의 안정성을 높이는 중요한 경제적 인센티브를 구현해볼 수 있습니다.
- **검증인 보상**: 블록을 성공적으로 생성한 검증인에게 트랜잭션 수수료나 새로운 토큰을 보상으로 지급하는 로직을 추가하여 PoS의 경제 모델을 시뮬레이션해볼 수 있습니다.

### 3. 역사증명 (Proof of History)

#### 구현 방식
`poh/` 디렉터리에서는 이벤트의 순차적인 발생 순서를 증명하는 PoH의 개념을 구현했습니다. `ProofOfHistory` 구조체는 해시값으로 연결된 이벤트의 `Sequence`를 유지합니다. `Record` 함수는 이전 해시값(`LastHash`)과 새로운 데이터를 결합하여 다음 해시를 생성하는 과정을 반복합니다. 이를 통해 누구도 순서를 바꾸거나 끼어들 수 없는, 암호학적으로 증명된 시간의 흐름을 만들어냅니다.

#### 개선 제안
- **PoS와 통합**: PoH는 그 자체로 합의 메커니즘이 아니라, 시간을 암호학적으로 증명하여 합의를 보조하는 기술입니다. 구현된 PoH를 PoS와 결합하여, PoH 시퀀스에 트랜잭션을 기록하고 PoS 검증인들이 이 시퀀스를 기반으로 블록을 제안하고 투표하는 전체적인 솔라나 방식의 아키텍처를 구현해볼 수 있습니다.
- **고빈도 최적화**: PoH는 매우 빠른 속도로 해시를 생성해야 합니다. 현재의 순차적인 `Record` 함수를 Go의 고루틴(goroutine)을 활용하여, 해시 생성 루프와 데이터 주입 루프를 분리하면 더 높은 성능의 PoH 시뮬레이션이 가능합니다.
- **데이터 주입**: 현재는 단일 소스에서 데이터를 `Record`하고 있습니다. 여러 출처의 트랜잭션이 PoH 스트림에 어떻게 효율적으로 삽입되고 순서가 증명되는지를 시뮬레이션하면 PoH의 실제적인 장점을 더 잘 보여줄 수 있습니다.
