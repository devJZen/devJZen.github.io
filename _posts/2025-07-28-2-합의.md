---
layout: post
title: Chapter 2-2. 합의 (Consensus)
categories: web3
tags: [Blockchain]
---
> 블록과 블록간의 연결을 인정하는 것을 합의라고 하고 합의의 방식을 합의 매커니즘(또는 합의 알고리즘)이라고 일컫는다.

합의를 통해 네트워크에 전파된 수많은 트랜잭션들의 순서를 결정하고, 모든 노드가 동일한 블록 순서에 동의하도록 만드는 과정이다. 이를 통해 블록체인의 무결성과 일관성을 보장한다.

웹 개발에서의 트랜잭션과 블록체인 트랜잭션은 '누가 먼저 시도하느냐에 따라 시점의 차이가 생긴다'는 점에서 유사한 개념적 연결 고리를 가진다. 하지만 블록체인, 특히 이더리움은 이러한 **시점의 차이와 동시성 문제를 '합의'를 통해 해결**한다.

블록체인에서의 시점의 차이는 중앙 서버가 아니라 노드들의 **합의 과정**을 통해 해결된다. 누가 먼저 트랜잭션을 전파했는가도 중요하지만, 궁극적으로는 합의 알고리즘에 따라 블록에 포함되고 순서가 결정된다. 이렇게 한 번 확정된 트랜잭션은 블록체인 네트워크에 영구적으로 기록된다. (단, 전통적 ACID 트랜잭션과는 차이가 있다. 블록체인은 일부 ACID 특성을 부분적으로 갖지만, DB의 ACID와는 보장 범위와 방식이 다르다.)

웹 개발의 트랜잭션이 특정 서버의 시간적 흐름에 따라 순서를 보장한다면, 블록체인의 트랜잭션은 **네트워크 전체가 합의한 시간적 흐름(블록체인)** 에 따라 순서를 보장한다는 점에서 근본적인 차이가 있다.

## 합의와 BFT는 동일한 개념이 아니다.

학습하며 가장 시간을 많이 할애한 부분이 P2P 프로토콜의 발전, 분산 시스템에서의 BFT와 최신 BFT 연구 동향이다.

논문을 읽을수록 합의와 BFT protocol의 기준이 모호하게 느껴졌다. 모든 체인에서 '합의'가 BFT 기반의 알고리즘으로 이루어질 수 밖에 없는 구조에 대해서 고민해봤더라면 더 빠른 개념확립이 이루어졌을 것이다.

분산 시스템은 모든 노드가 참여할 수 있는 환경을 제공하고 이 상황에서 가질 수 있는 최악의 변수를 정의한게 BFT다. 그렇기 때문에 합의 알고리즘을 논하는데에 있어서 BFT protocol을 제외하고 작성할 수 없었고 계속 등장하는 개념이라서 합의(Consensus) 자체를 'BFT protocol'이라고 혼동하게 됐다. 최악의 수를 어떻게 효율적으로 처리할 수 있는지에 대한 고민이 BFT로 부터 파생되었으나 합의 그 자체가 될 수는 없다.

모든 노드가 최악의 시나리오만 가지는 건 아니며 블록 상태 변화에 참여할 수 있는 방식도 다양하다.

## 합의(consensus)의 등장

> 분산화 된 환경에서의 최악의 시나리오는 뭘까?

분산 시스템에서 데이터를 주고 받는 과정에서 노드의 역할은 필연적이다. 트랜잭션의 유효성을 판단하기 위해서 노드의 상태 판단 기준을 정한게 '합의'의 시작이다.

분산 시스템에서 노드(컴퓨터)가 고장 나는 방식은 크게 두 가지로 나눌 수 있다.

- **단순 문제 (Crash Fault):** 노드가 그냥 멈추거나(crash), 응답하지 않는(unresponsive) 경우입니다. 거짓말을 하거나 시스템을 속이지는 않는다.
- **예시:** 갑자기 전원이 꺼진 서버, 네트워크 연결이 끊긴 컴퓨터.
- **해결책:** **CFT (Crash Fault Tolerance)** 알고리즘. 대표적으로 **Paxos**와 **Raft**가 있다.
- **비잔틴 문제 (Byzantine Fault):** 노드가 **악의를 가지고** 시스템을 교란하기 위해 어떤 행동이든 할 수 있는 경우다.
- **예시:**
  - A에게는 "X에 투표했다"고 말하고, B에게는 "Y에 투표했다"고 거짓말하는 노드.
  - 의도적으로 잘못된 데이터를 보내는 노드.
  - 다른 악의적인 노드와 담합하여 시스템을 공격하는 노드.
- **해결책:** **BFT (Byzantine Fault Tolerance)** 알고리즘. 대표적으로 **PBFT**, **Tendermint**, **HotStuff**가 있다.

BFT가 합의 달성 최악의 시나리오로 설정되기 때문에 이를 막을 수 있다면 그냥 멈추거나 응답하지 않는 경우까지 커버할 수있다는 이론이고 증명되었다. 비장틴 문제로 분산 시스템에서 신뢰할 수 없는 참여자들 사이의 합의가 얼마나 어려운지 정의했다. Web 2.0 시대는 통제된 환경이었기 때문에 CFT 수준의 합의로 충분했다. 그러나 비트코인으로 블록체인 기술이 상용화되며 금전적 보상이 걸린 분산 시스템의 환경이 대중화 됐다. 이 환경에서 시스템의 신뢰를 보장하기 위해 가장 비관적인 BFT를 해결하는 것이 필수 과제가 되었고 [BFT를 기반으로 많은 프로토콜](https://devjzen.github.io/web3/2025/07/31/%EC%B5%9C%EC%8B%A0-BFT-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C.html)이 존재하며, 네트워크 환경과 노드 수에 따라 성능과 한계가 다르다.

### 웹과 다른 분산 환경의 복잡성

- **글로벌 시계의 부재:** 분산 시스템의 각 노드는 중앙 시계가 없으므로 완벽하게 동기화된 단일 시점을 공유하지 못한다. 이로 인해 **논리적 시계(Logical Clocks)** 나 **벡터 시계(Vector Clocks)** 와 같은 개념을 사용하여 이벤트의 **인과 관계(Causality)** 를 추론한다.
- **부분적 실패 및 네트워크 지연:** 노드 충돌, 네트워크 파티션, 메시지 손실이나 지연 등의 문제가 발생할 수 있다. 이러한 불확실성 속에서도 시스템 전체의 일관성을 유지해야 하는 과제가 있다.
- **이더리움의 문제 해결 방식:** 이더리움은 **작업 증명(PoW)** 을 거쳐서 **지분 증명(PoS)** 과 같은 **합의 알고리즘**을 통하여 분산된 노드들이 트랜잭션의 순서와 블록의 유효성에 대해 **단일하게 동의**하도록 만든다.
- **결정론적 실행 환경(Deterministic Execution):** 이더리움의 **EVM(Ethereum Virtual Machine)** 은 **튜링 완전(Turing Complete)** 한 실행 환경을 제공하며, 동일한 초기 상태와 트랜잭션이 주어지면 **항상 동일한 결과**를 산출하도록 설계했다. 즉, 어떤 노드가 트랜잭션을 실행하더라도 결과는 예측 가능하고 ==일관적[^1]== 이다.
- **가스(Gas) 메커니즘:** 스마트 컨트랙트가 튜링 완전하기 때문에 무한 루프나 과도한 자원 소모로 인한 서비스 거부(DoS) 공격의 위험이 있다. **가스**는 이러한 연산에 필요한 컴퓨팅 자원의 양을 측정하고 제한하는 '연료' 역할을 한다. 트랜잭션이 할당된 `gasLimit`을 초과하면 실행이 중단되고 모든 상태 변경이 되돌려지며 사용된 가스는 소각된다. 이는 무분별한 연산을 방지하여 네트워크의 안정성을 유지하는 핵심적인 제어 메커니즘이다.
  합의는 시스템의 **상태 일관성**, **신뢰성**, **내결함성** 및 **분산된 통제**를 보장하여(트랜잭션의 ACID특성을 보장) 데이터 손상이나 영구적인 불일치를 방지한다.

### 최종성(Finality)

합의가 끝난 뒤 트랜잭션이 되돌릴 수 없는 상태가 되는 것을 의미한다. PoW는 확률적 최종성, BFT는 즉각적 최종성을 가진다.

---

## 1. 비트코인의 합의 매커니즘, 작업 증명 (PoW)

> 라운드에 작업량이 무수히 많은 노드를 기준으로 합의를 결정하자. 그 정도 노력을 했으면 거짓말 할 이유가 없을거야.

- 포크(Fork): 합의 실패 시 체인이 분기되기도 한다. PoW에서 자주 접할 수 있다.
- 시빌 저항(Sybil Resistance): 악의적 노드가 노드의 수를 늘려서 네트워크를 장악하지 못하도록 설계되었다. 노드가 자원을 소모해야만 블록 생성과 검증에 참여할 수 있다. PoW에서의 저항 방식은 연산력을 자원으로 사용한다. 블록을 생성하려면 막대한 전기와 하드웨어가 필요하다.
- **[비트코인](https://bitcoin.org/bitcoin.pdf)**: 작업 증명을 구현한 최초의 암호화폐인 비트코인의 탈중앙화 네트워크는 채굴자에게 의존하여 블록체인을 보호한다.
- **[라이트코인](https://litecoin.com/)**: 비트코인의 포크인 라이트코인은 작업 증명을 사용하지만 거래 시간이 더 빠르기 때문에 일상적인 소규모 거래에 더 적합하다.

## 2. 이더리움의 합의 매커니즘, 지분 증명 (Pos)

> 라운드에 가장 많은 재산을 맡긴 노드를 기준으로 합의를 결정하자. 그렇게 많은 재산을 투자했으면 거짓말 할 이유가 없을거야.

- 시빌 저항(Sybil Resistance): PoS에서 토큰(지분, stake)을 자원으로 사용한다. 블록 생성과 검증에 참여하려면 많은 코인을 예치해야한다. 물리적 자원 대신 경제적 자원이 등장한다. 토큰 분배 구조에 따라 중앙화 위험이 있다.
- **이더리움**: 2022년 작업 증명에서 지분 증명으로 전환한 [이더리움](https://ethereum.org/ko/)은 현재 에너지 효율성과 확장성을 크게 향상시킨 지분 증명을 사용하고 있다.
- **카르다노**: 연구 중심 접근 방식으로 유명한 선도적인 지분 증명 블록체인인 [카르다노](https://cardano.org/)는 스테이킹을 통해 보안과 지속 가능성을 강조한다.

## 3. 솔라나의 시간 관리 프로토콜, 역사 증명 (PoH)

> 라운드에 합의 제한 시간을 설정하고 그걸 타임스탬프로 보장하자. 이렇게 해야 많은 양의 합의를 처리할 수 있어.

- **솔라나**: [솔라나](https://solana.com/ko)는 역사 증명이라는 시간 관리 프로토콜을 사용하여 모든 노드의 로컬 가상 시계를 동기화한다. PoH는 모든 메시지의 타임스탬프를 신뢰할 수 있도록 보장하고, 모든 노드가 현재 시간과 새로운 합의 라운드를 시작할 시점을 알고 있기 때문에 합의 프로토콜의 시간 초과를 방지할 수 있다.
  > PoH는 합의 프로토콜의 효율성을 높이기 위한 시간 동기화 메커니즘으로, 단독 합의 매커니즘은 아니며, 시빌 저항 매커니즘과는 다른 접근이다. 

## 4. Cosmos의 합의 알고리즘 (Tendermint)

> 라운드에 전체 노드의 2/3 이상이 서명한 합의로 결정하자. 1/3의 노드가 반대해도 정직한 노드가 2/3를 차지하면 훌륭한 답이 될거야.

- 합의 실패 기준: 2/3 이상의 노드가 일치하지 않으면 합의가 성립되지 않는다.
- 높은 보안성과 즉시 확정(빠른 최종성)을 제공하지만 네트워크 확장성 측면에서 단순 투표 구조보다 불리하다. 그래서 검증인의 수를 제한하거나 샤딩/레이어2 등 확장성 솔루션과 함께 사용된다.
- Tendermint: [Tendermint](https://docs.tendermint.com/master/introduction/what-is-tendermint.html)는 PBFT를 기반으로 만들어진 합의 알고리즘이다. 블록체인 환경에 맞게 네트워크 분리, 빠른 최종성을 지원하며 개발 친화적으로 만들어졌다.

참고 문서: [작업 증명과 지분 증명](https://kr.beincrypto.com/learn-kr/proof-of-work-vs-proof-of-stake/#h-%EC%9E%91%EC%97%85-%EC%A6%9D%EB%AA%85-pow-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94), [PoH](https://ackee.xyz/solana/book/latest/chapter2/proof-of-history/), [BeinCrypto](https://kr.beincrypto.com/learn-kr/)

[^1]: 외부 입력(예: 블록 타임스탬프, 블록 넘버 등)에 따라 결과가 달라질 수 있다. [참조](https://ethereum.org/en/whitepaper/)
