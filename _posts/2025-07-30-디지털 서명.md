---
layout: post
title: Chapter 3-2. 디지털 서명
categories: web3
tags: [Blockchain]
---
## 1. 개요

디지털 메시지나 문서의 수학적 체계이며, 서명 생성 알고리즘과 서명 검증 알고리즘으로 크게 두가지로 분류된다. 이중 지불 문제를 해결하는 데 부분적인 역할을 완전히 방지하지는 못한다. 신뢰할 수 있는 P2P 네트워크가 필요하다.

## 2. 특성과 예시
유효한 디지털 서명은 수신자가 메시지가 알려진 발신자에 의해 생성되었음을 믿게 하고(인증)[^2] , 발신자가 메시지를 보냈다는 사실을 부인할 수 없게 하며(부인 방지)[^3] , 메시지가 전송 중에 변경되지 않았음을 보장한다.(무결성)[^4] [^1]

*공개 키 암호화(Public-key Cryptography)[^2]
*메시지 다이제스트(Message Digests) 또는 암호화 해시 함수[^5]
*ECDSA (Elliptic Curve Digital Signature Algorithm)[^6]
*EIP-155 (Simple Replay Attack Protection)
*오프라인 서명(Offline Signing)

## 3. 디지털 서명 과정 (Process)

디지털 서명은 '서명 생성'과 '서명 검증'이라는 두 단계의 알고리즘으로 구성된다. 전체 과정은 아래와 같이 시각화할 수 있다.

<div class="mermaid">
graph TD

    %% 송신자 영역 (부드러운 보라색)
    subgraph "서명 생성 (송신자)"
        direction LR
        A["① 메시지 원문"]
        B["② 메시지 다이제스트 (해시값)"]
        C["③ 암호화"]
        D["④ 디지털 서명"]

        A --> B
        B --> C
        C --> D

        %% 송신자 노드 색상
        classDef sender fill:#E6E6FA,stroke:#888,stroke-width:1px,rx:5,ry:5;
        class A,B,C,D sender;
    end

    %% 수신자 영역 (부드러운 하늘색)
    subgraph "서명 검증 (수신자)"
        direction LR
        E["① 수신한 메시지"]
        F["② 생성한 다이제스트"]
        G["③ 수신한 서명"]
        H["④ 복호화"]
        I["⑤ 비교"]
        J["⑥ 검증 결과"]

        E --> F
        G --> H
        F --> I
        H --> I
        I --> J

        %% 수신자 노드 색상
        classDef receiver fill:#D0EFFF,stroke:#888,stroke-width:1px,rx:5,ry:5;
        class E,F,G,H,I,J receiver;
    end

    %% 메시지와 서명 전송
    D -- 디지털 서명 전송 --> G
    A -- 메시지 전송 --> E
</div>

### 서명 생성 (Signing)

송신자는 자신의 개인키를 사용하여 서명을 생성한다.

1.  **해싱**: 서명할 메시지(M)를 해시 함수(H)에 넣어 고정 길이의 해시값, 즉 메시지 다이제스트(Message Digest)를 생성한다.
    - `Digest = H(M)`
2.  **암호화**: 생성된 다이제스트를 자신의 **개인키(Private Key)** 로 암호화(E)한다. 이 암호화된 결과물이 바로 '디지털 서명(Signature)'이다.
    - `Signature = E(privateKey, Digest)`
3.  **전송**: 원래의 메시지(M)와 생성된 디지털 서명(Signature)을 함께 수신자에게 전송한다.

### 서명 검증 (Verification)

수신자는 송신자의 공개키를 사용하여 서명의 유효성을 검증한다.

1.  **해싱**: 수신한 메시지(M')를 서명 생성 시 사용된 것과 동일한 해시 함수(H)에 넣어 메시지 다이제스트를 직접 생성한다.
    - `Received_Digest = H(M')`
2.  **복호화**: 메시지와 함께 받은 디지털 서명(Signature)을 송신자의 **공개키(Public Key)** 로 복호화(D)한다. 성공적으로 복호화되면 원본 메시지의 다이제스트가 나온다.
    - `Decrypted_Digest = D(publicKey, Signature)`
3.  **비교**: 1번 단계에서 직접 생성한 다이제스트(`Received_Digest`)와 2번 단계에서 복호화하여 얻은 다이제스트(`Decrypted_Digest`)가 일치하는지 비교한다.
    - `Received_Digest === Decrypted_Digest ? "검증 성공" : "검증 실패"`

두 해시값이 일치하면, 이 서명은 해당 공개키의 주인(송신자)이 생성했으며, 메시지는 전송 중에 위변조되지 않았음을 수학적으로 증명할 수 있다.

[^1]: Andreas M. Antonopoulos and Dr. Gavin Wood (2019). Mastering Ethereum
[^2]: Whitfield Diffie, Martin E. Hellman. "New Directions in Cryptography." IEEE Transactions on Information Theory, 1976.
[^3]: Leslie Lamport. "Constructing digital signatures from a one-way function." Technical Report CSL-98, SRI International, 1979.
[^4]: Taher ElGamal. "A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms." IEEE Transactions on Information Theory, 1985.
[^5]: Ralph C. Merkle. "Protocols for public key cryptosystems." IEEE Symposium on Security and Privacy, 1980.
[^6]: Don Johnson, Alfred Menezes, Scott Vanstone. "The Elliptic Curve Digital Signature Algorithm (ECDSA)." International Journal of Information Security, 2001.
